import pathlib
from typing import Union, Tuple

import pandas as pd
import numpy as np


class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    @staticmethod
    def valid_fname(file_name):
        try:
            file_name = pathlib.Path(file_name).resolve(strict=False)
            # Make the path absolute
            # If the path doesnâ€™t exist and strict is True, FileNotFoundError is raised.
            # TODO: Is FileNotFoundError instead of ValueError  okay?
        except TypeError:
            raise
        if not file_name.exists():
            raise ValueError(f"File {str(file_name)} doesn't exist.")
        return file_name

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        self.data_fname = self.valid_fname(data_fname)
        self.data = self.read_data()

    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """

        return pd.read_json(self.data_fname)

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants.

        Returns
        -------
        hist : np.ndarray
          Number of people in a given bin
        bins : np.ndarray
          Bin edges
        """

        bins = np.linspace(0, 100, 11)
        return self.data.hist(column="age", bins=bins), bins

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

    Returns
    -------
    df : pd.DataFrame
      A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
      the (ordinal) index after a reset.
        """
        email_pattern = self.data[self.data["email"].str.match(r"\w+\S*@{1}\w+.\w")]  # Using RegEx
        return email_pattern.reset_index(drop=True)

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

    Returns
    -------
    df : pd.DataFrame
      The corrected DataFrame after insertion of the mean grade
    arr : np.ndarray
          Row indices of the students that their new grades were generated
        """
        q_columns = self.data.filter(items=['q1', 'q2', 'q3', 'q4', 'q5'])
        return self.data.fillna(self.data.mean()['q1':'q5']), self.data[q_columns.isnull().any(axis=1)].index.to_numpy()


def main():
    fname = 'data.json'
    q = QuestionnaireAnalysis(fname)
    print(q.fill_na_with_mean())


if __name__ == '__main__':
    main()
